---
title: "Typologie"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# Packages
```{r}
library(httr)
library(tidyverse)
library(jsonlite)

install.packages("sf")
library(sf)

install.packages("mapsf")
library(mapsf)
```

# Sitadel
Il faut dans un premier temps récupérer les données de la construction SITADEL à partir de l'API DIDO du ministère du logement.
On accède ainsi au millésime le plus récent, filtré pour les données du rhône, transformé en format CSV.
```{r API_sitadel}
# API Dido pour récupérer les données de sitadel
## Formation de l'URL

### Base
base <- "https://data.statistiques.developpement-durable.gouv.fr:443/dido/api/v1/datafiles/8b35affb-55fc-4c1f-915b-7750f974446a/csv"

### Millésime
mil <- "?millesime=2024-01"

### Conditions colonnes obligatoire
condcol <- "&withColumnName=true&withColumnDescription=false&withColumnUnit=false&"

### Filtres
filtres <-
  list("&DEP_CODE=contains%3A69") # Département du Rhône


url <- paste0(base, mil, condcol, filtres)


## Collecte des données
cons69 <- httr::content(
  httr::GET(url),             # url correspond à l'url à interroger
  as = "raw",                # type de la sortie renvoyée
  type = httr::content_type("text/csv"),  # type de la réponse de l'url
  encoding = "UTF-8"          # encodage de la réponse de l'url
)
writeBin(cons69, "cons69.csv")
cons69 <- read_csv2("cons69.csv")
```




# Géocodage
```{r}
# Jointure API géocodage et base SITADEL de Lyon
## Création d'une variable url pour les constructions
### Base
base <- "https://wxs.ign.fr/essentiels/geoportail/geocodage/rest/0.1/search?q="

### Type de données
index <- "&index=parcel"

### Parcelle cadastrale des constructions
cons69 <-
  cons69 %>%
  mutate(
    ## URL à partir de la parcelle
    # Département
    depcode = paste0("&departmentcode=", DEP_CODE),
    # Arrondissement
    arr = 
      if_else(
         # Si dans Lyon
        COMM == "69123",
        # Alors récupère le code d'arrondissement dans le DAU
        paste0("&districtcode=", str_sub(NUM_DAU, 4, 6)),
        # Sinon assigne NA
        NA),
    # Section cadastrale
    sec = paste0("&section=", SEC_CADASTRE1),
    # Numéro
    number = paste0("&number=", 
                    # Ajusté à la taille de 4 caractères
                    str_pad(NUM_CADASTRE1, width = 4, pad = "0")),
    # URL final
    url_parc = 
      paste0(base, index, depcode, arr, sec, number),
    ## URL à partir de l'adresse
    # Information sur l'adresse
    # Première transformation
    adresse = 
      if_else(
        # Si le numéro est dans le libellé
        str_detect(ADR_LIBVOIE_TER, "\\d"),
        # Alors garde seulement le libellé
        ADR_LIBVOIE_TER,
        # Sinon cherche le numéro dans la colonne
        paste0(ADR_NUM_TER, " ", ADR_LIBVOIE_TER)),
    # Deuxième transformation
    # Remplace tous les espaces par des %
    adresse = str_replace_all(adresse, " ", "%"),
    # URL final, limité à 1 résultat
    url_adresse = paste0(base, adresse, "%6900", str_sub(NUM_DAU, 6, 6), "%Lyon", "&type=housenumber", "&limit=1"),
    # On ne cherche pas les constructions sans numéro de rue
    url_adresse = if_else(str_detect(url_adresse, "NA"), NA, url_adresse)
    )

### Filtre Lyon intra-muros et professionnels
conslyon <- 
  cons69 %>%
  filter(COMM == 69123 &
           str_starts(CAT_DEM, "3"))


### On créer des identifiants
conslyon <-
  conslyon %>%
  rowid_to_column("ID")

## Récupérer les coordonnées géographiques par l'API
### Fonction
myget <-
  function(url_parc) {
    # Récupération de l'information
      httr::content(
  httr::GET(url_parc),             # url correspond à l'url à interroger
  as = "text",                # type de la sortie renvoyée
  httr::content_type_json(),  # type de la réponse de l'url
  encoding = "UTF-8"          # encodage de la réponse de l'url
) %>%
      # Traduction du format JSON
      jsonlite::fromJSON(., flatten = T) %>%
      # Dont on ne garde que l'élément features qui est un data.frame
      pluck("features")
  }

### Fonction appliquée aux URL de chaque construction
res_parc <- 
  map2(
    # Argument 1 : les url
    .x = conslyon$url_parc,
    # Argument 2 = les identifiants
    .y = conslyon$ID,
    # Fonction : 
    .f = ~ 
      # Jointure de deux data.frame
      cbind(
        # Le data.frame du géocodage
        myget(.x), 
        # La colonne de l'identifiant
        "ID" = .y))

### On ne garde que les constructions dont on a retrouvé la localisation
res_parc <- res_parc[map(res_parc, length) == 15] %>%
  bind_rows()

# Géocodage par l'adresse
## Variable de filtre
conslyon <-
  conslyon %>%
  mutate(besoin_adresse = !(ID %in% res_parc$ID))

## Même fonction appliquée aux seules lignes nécessaires
res_adr <- 
  map2(
    # Argument 1 : les url
    .x = conslyon %>%
      filter(besoin_adresse & !is.na(url_adresse)) %>%
      pull(url_adresse),
    # Argument 2 = les identifiants
    .y = conslyon %>%
      filter(besoin_adresse & !is.na(url_adresse)) %>%
      pull(ID),
    # Fonction : 
    .f = ~ 
      # Jointure de deux data.frame
      cbind(
        # Le data.frame du géocodage
        myget(.x), 
        # La colonne de l'identifiant
        "ID" = .y))

res_adr <- res_adr %>%
  bind_rows() %>%
  filter(properties.type == "housenumber")


head(res_adr)


### Faire la jointure des deux listes
res <-
  rbind(
    select(res_parc, ID, geometry.coordinates),
    select(res_adr, ID, geometry.coordinates)
  ) %>%
  arrange(ID)

### Faire la jointure avec les constructions
conslyon <-
  left_join(conslyon,
          res, 
          by = "ID")

### Nombre de parcelles non situées
table(is.na(conslyon2$geometry.coordinates))
```

```{r}
t <- st_read("https://data.geopf.fr/wfs/ows?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&typeName=CADASTRALPARCELS.PARCELLAIRE_EXPRESS:arrondissement")

arr <-
  t %>%
  filter(str_starts(code_insee, "69"))



arr <- arr %>%
  st_cast("GEOMETRYCOLLECTION") %>%
  st_collection_extract("POLYGON")

mf_map(arr)
mf_map(sf_conslyon, add = T)


sf_conslyon <- st_as_sf(t,
                        coords = c("geometry.coordinates_1",
                                   "geometry.coordinates_2"))


t <- conslyon %>%
  unnest_wider(geometry.coordinates,
               names_sep = "_") %>%
  filter(!is.na(geometry.coordinates_1))


```

