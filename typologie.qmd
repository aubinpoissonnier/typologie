---
title: "Typologie"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# Packages
```{r}
library(httr)
library(tidyverse)
library(jsonlite)
```

# Sitadel
Il faut dans un premier temps récupérer les données de la construction SITADEL à partir de l'API DIDO du ministère du logement.
On accède ainsi au millésime le plus récent, filtré pour les données du rhône, transformé en format CSV.
```{r API_sitadel}
# API Dido pour récupérer les données de sitadel
## Formation de l'URL

### Base
base <- "https://data.statistiques.developpement-durable.gouv.fr:443/dido/api/v1/datafiles/8b35affb-55fc-4c1f-915b-7750f974446a/csv"

### Millésime
mil <- "?millesime=2024-01"

### Conditions colonnes obligatoire
condcol <- "&withColumnName=true&withColumnDescription=false&withColumnUnit=false&"

### Filtres
filtres <-
  list("&DEP_CODE=contains%3A69") # Département du Rhône


url <- paste0(base, mil, condcol, filtres)


## Collecte des données
cons69 <- httr::content(
  httr::GET(url),             # url correspond à l'url à interroger
  as = "raw",                # type de la sortie renvoyée
  type = httr::content_type("text/csv"),  # type de la réponse de l'url
  encoding = "UTF-8"          # encodage de la réponse de l'url
)
writeBin(cons69, "cons69.csv")
cons69 <- read_csv2("cons69.csv")
```




# Géocodage
```{r API_geocodage}
# API Géocodage pour récupérer les données du parcellaire express
## Formation de l'URL

### Base
base <- "https://wxs.ign.fr/essentiels/geoportail/geocodage/rest/0.1/search?q="

### Type de données
index <- "&index=parcel"

### Code département
depcode <- "&departmentcode=69"

### Municipalité
mun <- "&municipalitycode=381"

### Arrondissement
arr <- "&districtcode=381"

### Section
sec <- "&section=AV"

### Numéro
number <- "&number=0025"


url <- paste0(base, index, depcode, arr, sec, number)

## Collecte
res <- httr::content(
  httr::GET(url),             # url correspond à l'url à interroger
  as = "text",                # type de la sortie renvoyée
  httr::content_type_json(),  # type de la réponse de l'url
  encoding = "UTF-8"          # encodage de la réponse de l'url
)

```



```{r}
# Jointure API géocodage et base SITADEL de Lyon
## Création d'une variable url pour les constructions
### Base
base <- "https://wxs.ign.fr/essentiels/geoportail/geocodage/rest/0.1/search?q="

### Type de données
index <- "&index=parcel"

### Parcelle cadastrale des constructions
cons69 <-
  cons69 %>%
  mutate(
    # Département
    depcode = paste0("&departmentcode=", DEP_CODE),
    # Arrondissement
    arr = 
      if_else(
         # Si dans Lyon
        COMM == "69123",
        # Alors récupère le code d'arrondissement dans le DAU
        paste0("&districtcode=", str_sub(NUM_DAU, 4, 6)),
        # Sinon assigne NA
        NA),
    # Section cadastrale
    sec = paste0("&section=", SEC_CADASTRE1),
    # Numéro
    number = paste0("&number=", 
                    # Ajusté à la taille de 4 caractères
                    str_pad(NUM_CADASTRE1, width = 4, pad = "0")),
    # URL final
    url_parc = 
      paste0(base, index, depcode, arr, sec, number),
    # ID de la parcelle cadastrale pour la jointure consécutive
    id = paste0(DEP_CODE, str_sub(NUM_DAU, 4, 6), "000", SEC_CADASTRE1, str_pad(NUM_CADASTRE1, width = 4, pad = "0"))
  )

### Filtre Lyon intra-muros et professionnels
conslyon <- 
  cons69 %>%
  filter(COMM == 69123 &
           str_starts(CAT_DEM, "3"))

### Nombre de parcelles différentes
length(unique(conslyon$id))


## Récupérer les coordonnées géographiques par l'API
### Fonction
myget <-
  function(url_parc) {
    httr::content(
  httr::GET(url),             # url correspond à l'url à interroger
  as = "text",                # type de la sortie renvoyée
  httr::content_type_json(),  # type de la réponse de l'url
  encoding = "UTF-8"          # encodage de la réponse de l'url
)
  }

### Fonction appliquée aux URL de chaque construction
res <- lapply(conslyon$url, myget)

### Extraction des informations et mises sous forme de dataframe
res2 <-
  map(
    res,
    function(x){
      jsonlite::fromJSON(x,
                         flatten = T)$features
    }
  ) %>%
  bind_rows()


## Faire la jointure
conslyon <-
  left_join(conslyon,
          res2, 
          by = c("id" = "properties.id"))



## Nombre de parcelles non situées
table(conslyon$id %in% res2$properties.id)

t <- conslyon %>%
  filter(!(id %in% res2$properties.id))

# Géocodage par l'adresse
conslyon <-
  conslyon %>%
  mutate(
    besoin_adresse = !(id %in% res2$properties.id),
    adresse = 
      if_else(
        str_detect(ADR_LIBVOIE_TER, "\\d"),
        ADR_LIBVOIE_TER,
        paste0(ADR_NUM_TER, " ", ADR_LIBVOIE_TER)),
    adresse = str_replace_all(adresse, " ", "%"),
    url_adresse = paste0(base, adresse, "%6900", str_sub(NUM_DAU, 6, 6), "%Lyon", "&type=housenumber", "&limit=1"),
    url_adresse = if_else(str_detect(url_adresse, "NA"), NA, url_adresse))

conslyon <-
  conslyon %>%
  rowid_to_column("index")







res3 <- 
  conslyon %>%
  filter(besoin_adresse &
           !is.na(url_adresse)) %>%
  pull(url_adresse, index) 

%>%
  map(.f = ~ myget(.)) %>%
  map(.f = ~ jsonlite::fromJSON(., flatten = T)$features) %>%
  bind_rows() %>%
  filter(properties.type != "street")


```




